#!/bin/bash
#
# VRF admin script
#
# This script is mostly a wrapper around ip and cgroups commands used to
# create and configure VRFs. The intent is to provide a better and cleaner
# user experience for managing VRFs on Linux. Perhaps one day this becomes
# a subcommand of ip (ip vrf ...)

PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/cumulus/bin

PROG=${0##*/}

# Expected name of managment VRF device
# TO-DO: should this be in a config file?
MGMT_VRF=mgmt

SYSTEMD_DIR=/lib/systemd/system
SYSTEMD_USER=/etc/systemd/user
CFGDIR=/var/lib/cumulus-vrf

VERBOSE=0

################################################################################
# utilities

function log_cmd
{
	if [ $VERBOSE -eq 1 ]; then
		echo "${PROG}: $*"
	fi
}

function dev_exists
{
	ip link show dev ${1} >/dev/null 2>&1
}


# return device index for given device name

function dev_index
{
	local dev=$1
	local idx

	idx=$(ip -o link show dev ${dev} 2>/dev/null | awk '{print $1}')
	idx=${idx/:}
	echo $idx

	[ -z "$idx" ] && return 1

	return 0
}

# Look up master device for a link

function dev_get_master
{
	local dev=$1

	ip -o link show dev $dev | awk '{
	for (i = 0; i < NF; ++i)
		if ($i == "master") {
			j=i+1
			print $j
			i=NF
		}
	}'
}

function get_comm
{
	awk '$1 == "Name:" {print $2}' /proc/$1/status
}

function normalize_vrf_name
{
	local vrf=$1

	[ -z "$vrf" ] && return 1

	case "$vrf" in
		*vrf*) name=$vrf;;
		*) name=${vrf}-vrf;;
	esac

	echo $name
	return 0
}

################################################################################
# cgroup functions

function l3mdev_cgroup_exists
{
	if [ -e /sys/fs/cgroup/l3mdev ];
	then
		return 0
	fi

	echo
	echo "Cgroup for managing VRF context does not exist."
	echo "Has l3mdev cgroup patch been applied to kernel?"
	echo "If so has it been enabled?"
	echo

	return 1
}

function vrf_cgroup_exists
{
	local vrf=$1

	[ -e /sys/fs/cgroup/l3mdev/${vrf} ] && return 0

	echo "cgroup does not exist for VRF."

	return 1
}

# return l3mdev cgroup task is associated with
function vrf_get_cgroup
{
	local p=$1
	local c

	c=$(grep l3mdev /proc/$p/cgroup | awk -F':' '{print $NF}')
	# strip leading '/'; makes default VRF ""
	echo ${c/\/}
}

# configure cgroup for VRF
function vrf_configure_cgroup
{
	local vrf=$1

	l3mdev_cgroup_exists
	[ $? -ne 0 ] && return 0

	log_cmd "cgcreate -g l3mdev:/${vrf}"
	cgcreate -g l3mdev:/${vrf} || return 1

	log_cmd "cgset -r l3mdev.master-device=${vrf} ${vrf}"
	cgset -r l3mdev.master-device=${vrf} ${vrf}
}

function vrf_delete_cgroup
{
	log_cmd "cgdelete -g l3mdev:/${1}"
	cgdelete -g l3mdev:/${1}
}

################################################################################
# vrf device functions

function vrf_exists
{
	local vrf=${1}

	[ "$vrf" = "default" ] && return 0

	ip link show dev ${vrf} type vrf >/dev/null 2>&1
	return $?
}

# get table id for vrf device
function vrf_get_table
{
	ip -o -d link show dev ${1} 2>/dev/null | sed -e 's/.*vrf table \([0-9]*\) .*/\1/'
}

function vrf_table
{
	local vrf=$1

	vrf_exists $vrf
	if [ $? -ne 0 ]; then
		echo "VRF does not exist"
		return 1
	fi

	vrf_get_table $vrf
}

# return list of VRFs that have been created
function vrf_get_list
{
	ip -br link show type vrf | awk '{print $1}'
}

function vrf_add_rules
{
	local vrf=$1
	local tbid=$2

	# setup fib rules which direct lookups to the proper table
	ip ru add pref 200 oif ${vrf} table ${tbid} || return 1
	ip ru add pref 200 iif ${vrf} table ${tbid} || return 1
	ip -6 ru add pref 200 oif ${vrf} table ${tbid} || return 1
	ip -6 ru add pref 200 iif ${vrf} table ${tbid} || return 1

	return 0
}

function vrf_delete_rules
{
	local vrf=$1

	ip ru delete oif ${vrf}
	ip ru delete iif ${vrf}
	ip -6 ru delete oif ${vrf}
	ip -6 ru delete iif ${vrf}

	return 0
}

# setup default route for vrf - use a very poor metric so other
# default routes will take precedence. We need a default route
# to keep the lookups from dropping from one table to the next
function vrf_add_default_route
{
	local tbid=$1

	log_cmd "ip route add table ${tbid} unreachable default metric 240"
	ip route add table ${tbid} unreachable default metric 240 || return 1

	log_cmd "ip -6 route add table ${tbid} unreachable default metric 240"
	ip -6 route add table ${tbid} unreachable default metric 240 || return 1
}

function vrf_flush_table
{
	local tbid=$1

	log_cmd "ip route flush table ${tbid}"
	ip route flush table ${tbid}

	log_cmd "ip -6 route flush table ${tbid}"
	ip -6 route flush table ${tbid}
}

# Configure a VRF
function vrf_configure
{
	local vrf=$1
	local tbid=$2
	local mode=$3

	if [ -n "$mode" -a "$mode" != "boot" ]; then
		usage
		return 1
	fi

	# make sure old remnants of prior vrf are removed
	vrf_teardown ${vrf} ${tbid} 2>/dev/null

	vrf_add_default_route ${tbid}
	if [ $? -ne 0 ]; then
		echo "Failed to install default routes"
		return 1
	fi

	vrf_configure_cgroup ${vrf}
	if [ $? -ne 0 ]; then
		echo "Failed to configure cgroup"
		return 1
	fi

	# start systemd for VRF if it has been configured. Can not
	# systemctl during boot. For boot systemd config should already
	# exist and it will start up the service in a VRF
	if [ -z "${mode}" ]; then
		systemd_start_if_enabled ${vrf}
	fi

	return 0
}

# Remove all configuration for VRF
function vrf_teardown
{
	local vrf=$1
	local tbid=$2

	systemd_stop_vrf ${vrf}

	if [ -n "$tbid" ]; then
		vrf_flush_table ${tbid}
	fi

	vrf_delete_cgroup ${vrf}
}

function vrf_list
{
	local tbid
	local vrf

	if [ -n "$1" ]; then
		usage
		return 1
	fi

	printf "\n"
	printf "%-16s %-5s\n" "VRF" "Table"
	printf "%-16s %-5s\n" "----------------" "-----"

	vrf=$(vrf_get_list)
	for v in $vrf
	do
		tbid=$(vrf_get_table $v)
		printf "%-16s %5s\n" $v $tbid
	done

	echo

	return 0
}

# Unsupported option; for testing and tooling only
function vrf_add
{
	local vrf=${1}
	local tbid=${3}

	if [ "$2" != "table" -o -z "$3" -o -n "$4" ];
	then
		usage
		return 1
	fi

	if [ "${vrf}" = "default" ]; then
		echo "'default' is a reserved VRF name"
		return 1
	fi

	vrf_exists ${vrf}
	if [ $? -eq 0 ]; then
		echo "VRF already exists"
		return 1
	fi

	# create device
	ip link add ${vrf} type vrf table ${tbid}

	# echo "${tbid}  ${vrf}" > /etc/iproute2/rt_tables.d/${vrf}.conf

	vrf_add_rules ${vrf} ${tbid}

	vrf_configure ${vrf} ${tbid}

	ip link set dev ${vrf} up
}

# Unsupported option; for testing and tooling only
function vrf_delete
{
	local vrf=${1}
	local tbid=${2}

	if [ -z "$vrf" ];
	then
		usage
		return 1
	fi

	if [ "${vrf}" = "default" ]; then
		echo "Can not delete the default VRF"
		return 1
	fi

	# stop and disable and systemd services that might be running
	systemd_disable_vrf ${vrf}

	[ -z "$tbid" ] && tbid=$(vrf_get_table $vrf)
	# rm -f /etc/iproute2/rt_tables.d/${vrf}.conf

	ip link delete dev ${vrf} 2>/dev/null

	vrf_delete_rules ${vrf}

	vrf_teardown ${vrf} ${tbid} 2>/dev/null
}

################################################################################
# link management

function link_usage
{
	cat <<EOF

Links associated with VRF domains:
    $PROG link list [<vrf-name>]
EOF
    # Unsupported options for customers; tooling and automated testing only
    # $PROG link add <vrf-name> dev <dev-name>
    # $PROG link remove dev <dev-name>
}

function link_list_vrf
{
	local vrf=${1}

	dev_exists $vrf
	if [ $? -ne 0 ]; then
		echo "VRF does not exist"
		return 1
	fi

	printf "\nVRF: %-16s\n" $vrf
	echo "--------------------"

	ip -br link show master ${vrf}
}

function link_list
{
	local vrf="$*"

	if [ -z "$vrf" ]; then
		vrf=$(vrf_get_list)
	fi

	for v in $vrf
	do
		link_list_vrf ${v}
	done

	echo
}

function link_add
{
	local vrf=${1}
	local dev=${3}

	if [ "$2" != "dev" -o -z "$3" -o -n "$4" ];
	then
		link_usage
		return 1
	fi

	dev_exists $vrf
	if [ $? -ne 0 ]; then
		echo "VRF does not exist"
		return 1
	fi

	dev_exists $dev
	if [ $? -ne 0 ]; then
		echo "dev does not exist"
		return 1
	fi

	ip link set dev $dev master ${vrf}
}

function link_remove
{
	local dev=$2

	if [ "$1" != "dev" -o -z "$2" -o -n "$3" ];
	then
		link_usage
		return 1
	fi

	ip -o -d link show ${dev} 2>/dev/null | grep -q vrf_slave
	if [ $? -ne 0 ]; then
		echo "dev is not a VRF slave"
		return 1
	fi

	ip link set dev $dev nomaster
}

function link_cmd
{
	local cmd=$1
	shift

	case "$cmd" in
		ls|list|sh|show) link_list   $*;;

		####################################################
		# these options are for testing and tooling; they
		# are not intended for use by customers
		a|add)        link_add    $*;;
		r|rem|remove) link_remove $*;;
		####################################################

		help)         link_usage;;
		*)            link_usage; return 1;;
	esac
}

################################################################################
# route management

function route_usage
{
cat <<EOF

Routes for a VRF domain:
    $PROG route list [<vrf-name>]
EOF
    # Unsupported options for customers; tooling and automated testing only
    # $PROG route {add|delete} <vrf-name> <route spec>
    # $PROG route get <vrf-name> <host>
}

function route_show_vrf
{
	local vrf=${1}

	dev_exists $vrf
	if [ $? -ne 0 ]; then
		echo "VRF does not exist"
		return 1
	fi

	local tbid=$(vrf_get_table $vrf)

	printf "\nVRF: %-16s\n" $vrf
	echo "--------------------"

	ip route show table $tbid
	echo
	ip -6 route show table $tbid
}

function route_show
{
	local vrf="$*"

	if [ -z "$vrf" ];
	then
		vrf=$(vrf_get_list)
	fi

	for v in ${vrf}
	do
		route_show_vrf ${v}
	done

	echo
}

function route_add
{
	local vrf=${1}
	shift

	dev_exists $vrf
	if [ $? -ne 0 ]; then
		echo "VRF does not exist"
		return 1
	fi
	local tbid=$(vrf_get_table $vrf)

	ip route add table $tbid $*
}

function route_delete
{
	local vrf=${1}
	shift

	dev_exists $vrf
	if [ $? -ne 0 ]; then
		echo "VRF does not exist"
		return 1
	fi
	local tbid=$(vrf_get_table $vrf)

	ip route del table $tbid $*
}

function route_get
{
	local vrf=${1}
	shift

	dev_exists $vrf
	if [ $? -ne 0 ]; then
		echo "VRF does not exist"
		return 1
	fi

	ip route get oif $vrf $*
}

function route_cmd
{
	local cmd=$1
	shift

	case "$cmd" in
		ls|list|sh|show)  route_show $*;;
		get)          route_get $*;;

		####################################################
		# these options are for testing and tooling; they
		# are not intended for use by customers
		a|add)        route_add $*;;
		d|del|delete) route_delete $*;;
		####################################################

		help)         route_usage;;
		*)            route_usage; return 1;;
	esac
}


################################################################################
# task management

function task_usage
{
	cat <<EOF

Tasks and VRF domain asociation:
    $PROG task exec <vrf-name> <command>
    $PROG task list [<vrf-name>]
    $PROG task identify <pid>

    NOTE: This command affects only AF_INET and AF_INET6 sockets opened by the
          command that gets exec'ed. Specifically, it has *no* impact on netlink
          sockets (e.g., ip command).
EOF
}

function task_list_vrf
{
	local vrf=$1

	printf "\nVRF: %-16s\n" $vrf
	echo "-----------------------"

	local f="/sys/fs/cgroup/l3mdev/${vrf}/cgroup.procs"
	if [ ! -e $f ]; then
		echo "No cgroup for vrf"
	else
		while read p
		do
			c=$(get_comm $p)
			printf "%-16s  %5s\n" $c $p
		done < $f
	fi
}

# show VRF for specific task
function task_identify
{
	local do_prompt=0

	if [ "$1" = "prompt" ]; then
		do_prompt=1
		shift
	fi

	# allow syntax to be ... pid <pid>
	[ "$1" = "pid" ] && shift
	pid=$*

	# default to parent PID (not this commands PID)
	[ -z "$pid" ] && pid=$PPID

	c=$(vrf_get_cgroup $pid)
	if [ -n "$c" ]; then
		if [ $do_prompt = "1" ]; then
			c=$(normalize_vrf_name $c)
			echo ":$c"
		else
			echo "$c"
		fi
	elif [ $do_prompt != "1" ]; then
		echo "default"
	fi
}

function task_list
{
	local vrf

	# show all tasks in 1 or more VRFs
	vrf="$*"
	if [ -z "$vrf" ]; then
		vrf=$(vrf_get_list)
	fi

	for v in ${vrf}
	do
		task_list_vrf ${v}
	done

	echo
}

# This should only be used by experienced users and known contexts.
# Changing the context of a running task only affects future ipv4 and
# ipv6 sockets. This option is used by various OS scripts to set
# the context of a parent process before exec'ing another process
# - a proper example of this should be used.

function task_set
{
	local vrf=$1
	local pid=$2

	if [ -n "$3" ]; then
		task_usage
		return 1
	fi

	vrf_exists $vrf
	if [ $? -ne 0 ]; then
		echo "VRF does not exist"
		return 1
	fi
	[ -z "$pid" ] && pid=$PPID

	kill -0 $pid >/dev/null 2>&1
	if [ $? -ne 0 ]; then
		echo "Process does not exist"
		return 1
	fi

	if [ "$vrf" = "default" ]; then
		echo $pid >> /sys/fs/cgroup/l3mdev/cgroup.procs
	else
		vrf_cgroup_exists $vrf || return 1
		echo $pid >> /sys/fs/cgroup/l3mdev/${vrf}/cgroup.procs
	fi
}

function task_exec
{
	local vrf=$1
	shift

	vrf_exists $vrf
	if [ $? -ne 0 ]; then
		echo "VRF does not exist"
		return 1
	fi

	if [ -z "$1" ]; then
		echo "No command to run"
		return 1
	fi

	if [ "$vrf" = "default" ]; then
		cgexec -g l3mdev:/ $* 2>/dev/null
		rc=$?
	else
		cgexec -g l3mdev:${vrf} $* 2>/dev/null
		rc=$?
	fi

	if [ $rc -ne 0 ]; then
		echo "Failed to run command in VRF context."
	fi
	return $rc
}

function task_cmd
{
	local cmd=$1
	shift

	l3mdev_cgroup_exists
	[ $? -ne 0 ] && return 1

	case "$cmd" in
		sh|show|li|list|ls) task_list $*;;
		id|identify) task_identify $*;;

		# used for systemd; needs to be hidden as there are
		# caveats to change the vrf association of a running
		# task
		set)         task_set $*;;

		ex|exec)     task_exec $*;;

		help) task_usage;;
		*) task_usage; return 1;;
	esac
}


################################################################################
# systemd integration

function service_usage
{
	cat <<EOF

Tasks running under systemd in a VRF domain:
    $PROG service start  <vrf> {onboot} <service>
    $PROG service stop   <vrf> {onboot} <service>
    $PROG service status <vrf> {<service>}
EOF
}


# Sanity check on VRF name
# - can not add device exists check here because disable/stop
#   commands need to run even if VRF device does not exist

function valid_vrf
{
	local vrf=$1

	if [ -z "$vrf" ]; then
		echo "VRF not given"
		return 1
	fi

	if [ "$vrf" = "default" ]; then
		echo "This command is only used for non-default VRFs"
		return 1
	fi

	return 0
}

#
# Enable and start systemd user instance for a VRF
#
function systemd_enable_vrf
{
	local vrf=$1

	log_cmd "systemctl enable vrf@${vrf}.service"
	systemctl enable vrf@${vrf}.service

	log_cmd "systemctl start  vrf@${vrf}.service"
	systemctl start  vrf@${vrf}.service
	rc=$?

	# if we actually start systemd it takes a bit for it to
	# initialize and be ready to start services; moving too
	# fast and the service startup fails.
	sleep 2

	return $rc
}

#
# stop and disable systemd user instance for a VRF
#
function systemd_disable_vrf
{
	local vrf=$1

	log_cmd "systemctl stop vrf@${vrf}.service"
	systemctl stop vrf@${vrf}.service 2>/dev/null

	log_cmd "systemctl disable vrf@${vrf}.service"
	systemctl disable vrf@${vrf}.service 2>/dev/null

	return 0
}

function systemd_stop_vrf
{
	local vrf=$1

	log_cmd "systemctl stop vrf@${vrf}.service"
	systemctl stop vrf@${vrf}.service 2>/dev/null

	return 0
}

function systemd_start_if_enabled
{
	local vrf=$1

	systemctl is-enabled vrf@${vrf}.service >/dev/null 2>&1
	if [ $? -eq 0 ]; then
		log_cmd "systemctl start vrf@${vrf}.service"
		systemctl start vrf@${vrf}.service
	fi

	return 0
}

#
# add an entry from the onboot config file
#
function add_service_onboot
{
	local vrf=$1
	local service=$2
	local cfg=${CFGDIR}/${vrf}.conf

	mkdir -p ${CFGDIR}
	touch ${cfg}

	grep -q ${service} ${cfg}
	[ $? -eq 0 ] && return

	echo ${service} >> ${cfg}
}

#
# remove an entry from the onboot config file
#
function rm_service_onboot
{
	local vrf=$1
	local service=$2
	local cfg=${CFGDIR}/${vrf}.conf

	if [ ! -e ${cfg} ]; then
		return
	fi

	while read s
	do
		[ "$s" != "$service" ] && echo $s
	done < ${cfg} > ${cfg}.new

	mv ${cfg}.new ${cfg}
}

function normalize_systemd_service
{
	local service=$1
	local vrf=$2

	# for @ services put the vrf on the end
	case $service in
		*@) service=${service}${vrf};;
	esac

	echo $service
}

function systemd_symlink
{
	local vrf=$1
	local service=$2
	local oservice=$3

	# if this is a service@ then need to look for the service file
	# without the appended vrf -- ie., the original service name
	systemd_file=${SYSTEMD_DIR}/${oservice}.service
	user_file=${SYSTEMD_USER}/${service}.service

	if [ ! -e ${user_file} ]; then
		if [ ! -f ${systemd_file} ]; then
			echo "systemd service file not found. Can not enable in VRF"
			return 1
		fi
		ln -s ${systemd_file} ${user_file}
	fi

	return 0
}

#
# start a service within a VRF context
#
function service_start
{
	local vrf=$1
	local onboot="no"
	local service

	valid_vrf $vrf || return 1

	vrf_exists $vrf
	if [ $? -ne 0 ]; then
		echo "VRF does not exist"
		return 1
	fi

	vrf_cgroup_exists $vrf || return 1

	shift
	if [ "$1" = "onboot" ]; then
		onboot=yes
		shift
	fi

	oservice=$1
	if [ -z "${oservice}" ]; then
		echo "Service not given"
		return 1
	fi
	service=$(normalize_systemd_service ${oservice} ${vrf})

	# make sure systemd in VRF is enabled
	systemd_enable_vrf $vrf
	[ $? -ne 0 ] && return 1

	# create symlink for service to user directory
	systemd_symlink ${vrf} ${service} ${oservice}
	[ $? -ne 0 ] && return 1

	if [ "$onboot" = "yes" ]; then
		add_service_onboot ${vrf} ${service}
	fi

	XDG_RUNTIME_DIR=/run/systemd-${vrf}
	export XDG_RUNTIME_DIR

	systemctl --user start ${service}
}

function service_stop
{
	local vrf=$1
	local onboot="no"
	local service

	valid_vrf $vrf || return 1

	shift
	if [ "$1" = "onboot" ]; then
		onboot=yes
		shift
	fi

	oservice=$1
	if [ -z "$oservice" ]; then
		echo "Service not given"
		return 1
	fi
	service=$(normalize_systemd_service ${oservice} ${vrf})

	XDG_RUNTIME_DIR=/run/systemd-${vrf}
	export XDG_RUNTIME_DIR

	if [ "$onboot" = "yes" ]; then
		rm_service_onboot ${vrf} ${service}
	fi

	systemctl --user stop $service
}

function service_status
{
	local vrf=$1
	local service=$2

	if [ -z "$vrf" ]; then
		vrf=$(task_identify)
	fi

	valid_vrf $vrf || return 1

	XDG_RUNTIME_DIR=/run/systemd-${vrf}
	export XDG_RUNTIME_DIR

	# empty ${service} gives status for all services
	systemctl --user status -l ${service}
}

function service_cmd
{
	local cmd=$1
	shift

	l3mdev_cgroup_exists
	[ $? -ne 0 ] && return 1

	case "$cmd" in
		start)  service_start $*;;
		stop)   service_stop $*;;
		status) service_status $*;;
		help) service_usage;;
		*) service_usage; return 1;;
	esac
}

################################################################################
# Management VRF

function mgmt_usage
{
	cat <<EOF

Management VRF domain:
    $PROG mgmt status
EOF
}

# Determine if management VRF is enabled. Check looks solely for
# the expected management VRF device name. If a customer / user
# decides to name it something else this check will fail.
# Can add check for eth0, eth1, ... enslavement (is it enslaved
# to a VRF device) but even that has limits.

function mgmt_status
{
	local rc
	local modstr

	vrf_exists $MGMT_VRF
	rc=$?

	# make sure mgmt device has at least 1 device enslaved
	# otherwise it means mgmt is defined but not used
	if [ $rc -eq 0 ]; then
		n=$(ip -br link show master $MGMT_VRF | wc -l)
		[ $n -eq 0 ] && rc=1
	fi

	[ $rc -ne 0 ] && modstr="NOT "
	echo "Management VRF is ${modstr}enabled."

	return $rc
}

function mgmt_cmd
{
	local cmd=$1
	shift

	case "$cmd" in
		status) mgmt_status $*;;

		# used by profile.d hook
		# $PROG mgmt set <pid>
		set) task_set $MGMT_VRF $*;;

		# return table id for MGMT_VRF. Used by dhclient hook
		# $PROG mgmt table
		table) vrf_table $MGMT_VRF;;

		# return name of management VRF device. Used by ping and
		# traceroute wrapper and vrf-dns-helper
		name|dev) echo $MGMT_VRF; return 0;;

		help) mgmt_usage;;
		*) mgmt_usage; return 1;;
	esac
}

################################################################################
# verify config for existing vrfs

# Run a few checks against management vrf expectations

function verify_mgmt_vrf
{
	local mgmt_exists=0
	local rc=0
	local mdev

	echo

	vrf_exists $MGMT_VRF
	if [ $? -ne 0 ]; then
		echo "Management VRF does not exist"
	else
		mgmt_exists=1
		echo "Management VRF exists"

		mdev=$(ip -br li sh master $MGMT_VRF | awk '{print $1}')
		if [ -z "$mdev" ]; then
			echo "    ERROR: Management VRF exists with no enslaved devices"
			rc=1
		else
			echo "    Management VRF interface: " $mdev
		fi

		verify_vrf_cgroup $MGMT_VRF
	fi

	# eth0 should exist and be checked with warning level
	# eth1 may exist and it is just informational

	local level="WARNING: "
	for d in eth0 eth1
	do
		dev_exists $d || continue

		m=$(dev_get_master $d)
		if [ -n "$m" ]; then
			if [ "$m" = "$MGMT_VRF" ]; then
				echo "    $d is enslaved to Management VRF"
			else
				echo "    ${level}$d is enslaved to $m"
			fi
		else
			if [ $mgmt_exists -eq 1 ]; then
				echo "    ${level}$d is not enslaved to management VRF"
			else
				echo "    $d is not enslaved"
			fi
		fi
		level="INFO: "
	done

	return $rc
}

function verify_vrf_cgroup
{
	local vrf=$1

	vrf_cgroup_exists $vrf >/dev/null 2>&1
	if [ $? -ne 0 ]; then
		echo "    ERROR: cgroup does not exist"
		return 1
	fi

	idx=$(dev_index $vrf)
	if [ $? -ne 0 ]; then
		echo "    ERROR: Failed to get device index; cgroup may be misconfigured"
		return 1
	fi

	# l3mdev.master-device file has line:
	#     net[4026531957]: device index 62 ==> red
	# important part is the index N ==> dev-name

	grep -q "index $idx ==> $vrf" /sys/fs/cgroup/l3mdev/${vrf}/l3mdev.master-device
	if [ $? -ne 0 ]; then
		echo "    ERROR: cgroup is misconfigured"
		return 1
	fi

	echo "    cgroup looks ok"

	return 0
}

function verify_local_table
{
	local rc=0

	echo
	echo "Checking rules for local table:"

	ip ru ls | egrep -q "^0:.*from all lookup local"
	if [ $? -eq 0 ]; then
		echo "    ERROR: IPv4 rule for local table should be after VRFs"
		rc=1
	fi

	ip -6 ru ls | egrep -q "^0:.*from all lookup local"
	if [ $? -eq 0 ]; then
		echo "    ERROR: IPv6 rule for local table should be after VRFs"
		rc=1
	fi

	[ $rc -eq 0 ] && echo "    rules for local tables look ok"

	return $rc
}

function ip_ru_verify
{
	local vrf=$1
	local tbid=$2
	local ver=$3
	local desc="IPv4"
	local cmd="ip ru ls"
	local rc=0
	local d

	if [ "$ver" = "6" ]; then
		desc="IPv6"
		cmd="ip -6 ru ls"
	fi

	# make sure the FIB rules exist; routing requires it

	for d in iif oif
	do
		$cmd | grep -q "from all $d $vrf lookup $vrf"
		if [ $? -ne 0 ]; then
			$cmd | grep -q "from all $d $vrf lookup $tbid"
			if [ $? -ne 0 ]; then
				echo "    ERROR: $desc $d fib rule is missing (see $cmd)"
				rc=1
			fi
		fi

		# make sure there is only 1 FIB rule; duplicate rules affect
		# performance
		n=$($cmd | grep "from all $d $vrf lookup" | wc -l)
		if [ $n -gt 1 ]; then
			echo "    WARNING: More than 1 $desc $d fib rules are present (see $cmd)"
			rc=1
		fi
	done

	return $rc
}

function verify_vrf_fib_rules
{
	local vrf=$1
	local tbid=$2
	local rc=0

	ip_ru_verify $vrf $tbid "4"
	[ $? -ne 0 ] && rc=1
	ip_ru_verify $vrf $tbid "6"
	[ $? -ne 0 ] && rc=1

	[ $rc -eq 0 ] && echo "    FIB rules look ok"

	return $rc
}

function verify_cmd
{
	local vrf
	local tbid
	local rc=0
	local n=0

	n=$(ip -br link show type vrf | wc -l)
	if [ $n -eq 0 ]; then
		echo "No VRFs have been configured"
		return 0
	fi

	verify_mgmt_vrf
	[ $? -ne 0 ] && rc=1

	vrf_get_list |
	while read vrf
	do
		# managemnet vrf handled in verify_mgmt_vrf
		[ "$vrf" = "$MGMT_VRF" ] && continue

		echo

		tbid=$(vrf_get_table $vrf)
		if [ -z "$tbid" ]; then
			echo "ERROR: VRF $vrf: failed to get table id; VRF is misconfigured"
			rc=1
			continue
		fi

		echo "VRF $vrf table $tbid"

		verify_vrf_fib_rules $vrf $tbid
		[ $? -ne 0 ] && rc=1

		verify_vrf_cgroup $vrf
		[ $? -ne 0 ] && rc=1
	done

	verify_local_table
	[ $? -ne 0 ] && rc=1

	ip ru ls | grep -q '\[detached\]'
	if [ $? -eq 0 ]; then
		echo
		echo "ERROR: Detached IPv4 FIB rules need to be removed. See ip ru ls"
	fi

	ip -6 ru ls | grep -q '\[detached\]'
	if [ $? -eq 0 ]; then
		echo
		echo "ERROR: Detached IPv6 FIB rules need to be removed. See ip ru ls"
	fi

	echo

	return $rc
}

################################################################################
# usage

function usage
{
	cat <<EOF
$PROG <OPTS>

VRF domains:
    $PROG list
EOF
	link_usage
	route_usage
	task_usage
	service_usage
	mgmt_usage
}

################################################################################
# main

# enable verbose logging?
if [ "$1" = "-v" ]; then
	VERBOSE=1
	shift
fi

CMD=$1
shift
case "$CMD" in
	ls|list|sh|show) vrf_list $*;;

	# bash profile scripts for checking if a vrf exists
	# $PROG exists <vrf-name>
	exists) vrf_exists $*;;

	# task commands
	t|ta|task) task_cmd $*;;

	# allowed shortcut: $PROG exec <vrf> <cmd>
	exec) task_cmd  exec $*;;

	s|service)  service_cmd $*;;

	# vrf identify   (show VRF for task)
	id|identify)   task_identify $*;;

	li|link)  link_cmd $*;;
	ro|route) route_cmd $*;;

	m|mgmt) mgmt_cmd $*;;

	####################################################
	# used by ifupdown2
	configure) vrf_configure $*;;
	teardown)  vrf_teardown  $*;;

	####################################################
	# these options are for testing and tooling; they
	# are not intended for use by customers
	add)        vrf_add $*;;
	del|delete) vrf_delete $*;;

	c|cgroup)   vrf_configure_cgroup $*;;
	verify)     verify_cmd;;
	# end unsupported options
	####################################################

	help) usage; exit 0;;
	*) usage; exit 1;;
esac
