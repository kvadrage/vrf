#!/bin/bash
#
# VRF admin script
#
# This script is mostly a wrapper around ip and cgroups commands used to
# create and configure VRFs. The intent is to provide a better and cleaner
# user experience for managing VRFs on Linux. Perhaps one day this becomes
# a subcommand of ip (ip vrf ...)

PROG=${0##*/}

# Expected name of managment VRF device
# TO-DO: should this be in a config file?
MGMT_VRF=mgmt

SYSTEMD_DIR=/lib/systemd/system
SYSTEMD_USER=/etc/systemd/user
MGMT_VRF_SERVICE=${SYSTEMD_DIR}/mgmt-vrf.service
CFGDIR=/var/lib/cl-vrf

################################################################################
# utilities

function dev_exists
{
	ip link show dev ${1} >/dev/null 2>&1
}

function get_comm
{
	awk '$1 == "Name:" {print $2}' /proc/$1/status
}

function normalize_vrf_name
{
	local vrf=$1

	[ -z "$vrf" ] && return 1

	case "$vrf" in
		*vrf*) name=$vrf;;
		*) name=${vrf}-vrf;;
	esac

	echo $name
	return 0
}

################################################################################
# cgroup functions

function l3mdev_cgroup_exists
{
	if [ -e /sys/fs/cgroup/l3mdev ];
	then
		return 0
	fi

	echo
	echo "Cgroup for managing VRF context does not exist."
	echo "Has l3mdev cgroup patch been applied to kernel?"
	echo "If so has it been enabled?"
	echo

	return 1
}

function vrf_cgroup_exists
{
	local vrf=$1

	[ -e /sys/fs/cgroup/l3mdev/${vrf} ] && return 0

	echo "cgroup does not exist for VRF."

	return 1
}

# return l3mdev cgroup task is associated with
function vrf_get_cgroup
{
	local p=$1
	local c

	c=$(grep l3mdev /proc/$p/cgroup | awk -F':' '{print $NF}')
	# strip leading '/'; makes default VRF ""
	echo ${c/\/}
}

function vrf_cgroup
{
	local vrf=$1

	l3mdev_cgroup_exists
	[ $? -ne 0 ] && return 0

	# configure cgroup
	which cgcreate >/dev/null 2>&1
	if [ $? -ne 0 ]; then
		echo "cgcreate not found. cgroups tools installed?"
		return 1
	fi
	cgcreate -g l3mdev:${vrf}

	which cgset >/dev/null 2>&1
	if [ $? -ne 0 ]; then
		echo "cgset not found. cgroups tools installed?"
		return 1
	fi
	cgset -r l3mdev.master-device=${vrf} ${vrf}
}

################################################################################
# vrf device functions

function vrf_exists
{
	local vrf=${1}

	[ "$vrf" = "default" ] && return 0

	dev_exists $vrf
}

# get table id for vrf device
function vrf_get_table
{
	ip -d link show dev ${1} 2>/dev/null | \
	awk '{
		for (i=1; i<NF; ++i) {
			if ($i == "table") {
				j=i+1
				id=$j
			}
		}
	} END { print id }'
}

function vrf_table
{
	local vrf=$1
	
	vrf_exists $vrf
	if [ $? -ne 0 ]; then
		echo "VRF does not exist"
		return 1
	fi

	vrf_get_table $vrf
}

# return list of VRFs that have been created
function vrf_get_list
{
	local c

	if [ "$1" != "-a" ]; then
		c=$(vrf_get_cgroup $$)

		# if task is associated with vrf only return that vrf
		if [ -n "$c" ]; then
			echo $c
			return 0
		fi
	fi

	ip -br link show type vrf | awk '{print $1}'
}

# create a VRF device, add FIB rules, set VRF link up, create id to table
# for iproute2
function do_vrf_create
{
	local vrf=$1
	local tbid=$2

	# create device
	ip link add ${vrf} type vrf table ${tbid}

	# echo "${tbid}  ${vrf}" > /etc/iproute2/rt_tables.d/${vrf}.conf

	# setup fib rules which direct lookups to the proper table
	ip ru add pref 200 oif ${vrf} table ${tbid}
	ip ru add pref 200 iif ${vrf} table ${tbid}
	ip -6 ru add pref 200 oif ${vrf} table $tbid
	ip -6 ru add pref 200 iif ${vrf} table $tbid

	# setup default route for vrf
	if [ "${vrf}" != "mgmt" ]; then
		ip route add table ${tbid} unreachable default
		ip -6 route add table ${tbid} unreachable default
	fi

	ip link set dev ${vrf} up

	vrf_cgroup $vrf
}

function do_vrf_delete
{
	local vrf=$1
	local tbid=$(vrf_get_table $vrf)

	if [ -z "$tbid" ]; then
		dev_exists ${vrf}
		if [ $? -eq 0 ]; then
			echo "Failed to lookup table id"
		else
			echo "vrf does not exist"
		fi
		return 1
	fi

	# rm -f /etc/iproute2/rt_tables.d/${vrf}.conf

	ip link delete dev ${vrf}
	ip route del table ${tbid} default
	ip -6 route del table ${tbid} default

	ip ru delete oif ${vrf}
	ip ru delete iif ${vrf}
	ip -6 ru delete oif -${vrf}
	ip -6 ru delete iif ${vrf}

	cgdelete -g l3mdev:${vrf} 2>/dev/null
}

function vrf_list
{
	local tbid
	local vrf

	if [ -n "$1" ]; then
		usage
		return 1
	fi

	printf "\n"
	printf "%-16s %-5s\n" "VRF" "Table"
	printf "%-16s %-5s\n" "----------------" "-----"

	vrf=$(vrf_get_list -a)
	for v in $vrf
	do
		tbid=$(vrf_get_table $v)
		printf "%-16s %5s\n" $v $tbid
	done

	echo

	return 0
}

# Unsupported option; for testing and tooling only
function vrf_add
{
	local vrf=${1}

	if [ "$2" != "table" -o -z "$3" -o -n "$4" ];
	then
		usage
		return 1
	fi

	do_vrf_create ${vrf} $3
}

# Unsupported option; for testing and tooling only
function vrf_delete
{
	local vrf=${1}

	if [ -z "$1" -o -n "$2" ];
	then
		usage
		return 1
	fi

	do_vrf_delete ${vrf}
}

################################################################################
# link management

function link_usage
{
	cat <<EOF

Links associated with VRF domains:
    $PROG link list [<vrf-name>]
EOF
    # Unsupported options for customers; tooling and automated testing only
    # $PROG link add <vrf-name> dev <dev-name>
    # $PROG link remove dev <dev-name>
}

function link_list_vrf
{
	local vrf=${1}

	dev_exists $vrf
	if [ $? -ne 0 ]; then
		echo "VRF does not exist"
		return 1
	fi

	echo
	echo "VRF $vrf"
	echo "--------------------"

	ip -br link show master ${vrf}
}

function link_list
{
	local vrf=$1

	if [ -n "$2" ];
	then
		link_usage
		return 1
	fi

	if [ -z "$vrf" ]; then
		vrf=$(vrf_get_list)
	fi

	for v in $vrf
	do
		link_list_vrf ${v}
	done

	echo
}

function link_add
{
	local vrf=${1}
	local dev=$3

	if [ "$2" != "dev" -o -z "$3" -o -n "$4" ];
	then
		link_usage
		return 1
	fi

	dev_exists $vrf
	if [ $? -ne 0 ]; then
		echo "VRF does not exist"
		return 1
	fi

	dev_exists $dev
	if [ $? -ne 0 ]; then
		echo "dev does not exist"
		return 1
	fi

	ip link set dev $dev master ${vrf}
}

function link_remove
{
	local dev=$2

	if [ "$1" != "dev" -o -z "$2" -o -n "$3" ];
	then
		link_usage
		return 1
	fi

	dev_exists $dev
	if [ $? -ne 0 ]; then
		echo "dev does not exist"
		return 1
	fi

	ip link set dev $dev nomaster
}

function link_cmd
{
	local cmd=$1
	shift

	case "$cmd" in
		l|li|ls|list) link_list   $*;;

		####################################################
		# these options are for testing and tooling; they
		# are not intended for use by customers
		a|add)        link_add    $*;;
		r|rem|remove) link_remove $*;;
		####################################################

		help)         link_usage;;
		*)            link_usage; return 1;;
	esac
}

################################################################################
# route management

function route_usage
{
cat <<EOF

Routes for a VRF domain:
    $PROG route list [<vrf-name>]
EOF
    # Unsupported options for customers; tooling and automated testing only
    # $PROG route {add|delete} <vrf-name> <route spec>
    # $PROG route get <vrf-name> <host>
}

function route_show_vrf
{
	local vrf=${1}

	dev_exists $vrf
	if [ $? -ne 0 ]; then
		echo "VRF does not exist"
		return 1
	fi

	local tbid=$(vrf_get_table $vrf)

	echo
	echo "VRF $vrf" 
	echo "--------------------"

	ip route show table $tbid
	echo
	ip -6 route show table $tbid
}

function route_show
{
	local vrf=${1}

	if [ -n "$2" ];
	then
		route_usage
		return 1
	fi

	if [ -z "$vrf" ];
	then
		vrf=$(vrf_get_list)
	fi

	for v in ${vrf}
	do
		route_show_vrf ${v}
	done

	echo
}

function route_add
{
	local vrf=${1}
	shift

	dev_exists $vrf
	if [ $? -ne 0 ]; then
		echo "VRF does not exist"
		return 1
	fi
	local tbid=$(vrf_get_table $vrf)

	ip route add table $tbid $*
}

function route_delete
{
	local vrf=${1}
	shift

	dev_exists $vrf
	if [ $? -ne 0 ]; then
		echo "VRF does not exist"
		return 1
	fi
	local tbid=$(vrf_get_table $vrf)

	ip route del table $tbid $*
}

function route_get
{
	local vrf=${1}
	shift

	dev_exists $vrf
	if [ $? -ne 0 ]; then
		echo "VRF does not exist"
		return 1
	fi

	ip route get oif $vrf $*
}

function route_cmd
{
	local cmd=$1
	shift

	case "$cmd" in
		s|sh|show|li|ls|list)  route_show $*;;
		get)          route_get $*;;

		####################################################
		# these options are for testing and tooling; they
		# are not intended for use by customers
		a|add)        route_add $*;;
		d|del|delete) route_delete $*;;
		####################################################

		help)         route_usage;;
		*)            route_usage; return 1;;
	esac
}


################################################################################
# task management

function task_usage
{
	cat <<EOF

Tasks and VRF domain asociation:
    $PROG task exec <vrf-name> <command>
    $PROG task list [<vrf-name>]
    $PROG task identify <pid>
EOF
}

function task_list_vrf
{
	local vrf=$1

	printf "\n"
	printf "VRF %s\n" $vrf
	echo "-----------------------"

	local f="/sys/fs/cgroup/l3mdev/${vrf}/cgroup.procs"
	if [ ! -e $f ]; then
		echo "No cgroup for vrf"
	else
		while read p
		do
			c=$(get_comm $p)
			printf "%-16s  %5s\n" $c $p
		done < $f
	fi
}

# show VRF for specific task
function task_identify
{
	local do_prompt=0

	if [ "$1" = "prompt" ]; then
		do_prompt=1
		shift
	fi

	# allow syntax to be ... pid <pid>
	[ "$1" = "pid" ] && shift
	pid=$*

	# default to parent PID (not this commands PID)
	[ -z "$pid" ] && pid=$PPID

	c=$(vrf_get_cgroup $pid)
	if [ -n "$c" ]; then
		if [ $do_prompt = "1" ]; then
			c=$(normalize_vrf_name $c)
			echo "[$c] "
		else
			echo "$c"
		fi
	elif [ $do_prompt != "1" ]; then
		echo "default"
	fi
}

function task_list
{
	local vrf

	# show all tasks in 1 or more VRFs
	vrf="$*"
	if [ -z "$vrf" ]; then
		vrf=$(vrf_get_list)
	fi

	for v in ${vrf}
	do
		task_list_vrf ${v}
	done

	echo
}

# This should only be used by experienced users and known contexts.
# Changing the context of a running task only affects future ipv4 and
# ipv6 sockets. This option is used by various OS scripts to set
# the context of a parent process before exec'ing another process
# - a proper example of this should be used.

function task_set
{
	local vrf=$1
	local pid=$2

	if [ -n "$3" ]; then
		task_usage
		return 1
	fi

	vrf_exists $vrf
	if [ $? -ne 0 ]; then
		echo "VRF does not exist"
		return 1
	fi
	[ -z "$pid" ] && pid=$PPID

	kill -0 $pid >/dev/null 2>&1
	if [ $? -ne 0 ]; then
		echo "Process does not exist"
		return 1
	fi

	if [ "$vrf" = "default" ]; then
		echo $pid >> /sys/fs/cgroup/l3mdev/cgroup.procs
	else
		vrf_cgroup_exists $vrf || return 1
		echo $pid >> /sys/fs/cgroup/l3mdev/${vrf}/cgroup.procs
	fi
}

function task_exec
{
	local vrf=$1
	shift

	vrf_exists $vrf
	if [ $? -ne 0 ]; then
		echo "VRF does not exist"
		return 1
	fi

	which cgexec >/dev/null 2>&1
	if [ $? -ne 0 ]; then
		echo "cgexec not found. cgroups tools installed?"
		return 1
	fi

	if [ "$vrf" = "default" ]; then
		cgexec -g l3mdev:/ $*
	else
		cgexec -g l3mdev:${vrf} $*
	fi
}

function task_cmd
{
	local cmd=$1
	shift

	l3mdev_cgroup_exists
	[ $? -ne 0 ] && return 1

	case "$cmd" in
		sh|show|li|list|ls) task_list $*;;
		id|identify) task_identify $*;;

		# used for systemd; needs to be hidden as there are
		# caveats to change the vrf association of a running
		# task
		set)         task_set $*;;

		ex|exec)     task_exec $*;;

		help) task_usage;;
		*) task_usage; return 1;;
	esac
}


################################################################################
# systemd integration

function service_usage
{
	cat <<EOF

Tasks running under systemd in a VRF domain:
    $PROG service start  <vrf> {onboot} <service>
    $PROG service stop   <vrf> {onboot} <service>
    $PROG service status <vrf> {<service>}
EOF
}


# Sanity check on VRF name
# - can not add device exists check here because disable/stop
#   commands need to run even if VRF device does not exist

function valid_vrf
{
	local vrf=$1

	if [ -z "$vrf" ]; then
		echo "VRF not given"
		return 1
	fi

	if [ "$vrf" = "default" ]; then
		echo "This command is only used for non-default VRFs"
		return 1
	fi

	if [ "$vrf" != "mgmt" ]; then
		echo "This command is currently limited to management VRF."
		return 1
	fi

	return 0
}

#
# Enable and start systemd user instance for a VRF
#
function systemd_enable_vrf
{
	local vrf=$1
	local f

	vrf_exists $vrf
	if [ $? -ne 0 ]; then
		echo "VRF does not exist"
		return 1
	fi

	# convert VRF name to systemd service name
	# - want to include "vrf" in the service name

	name=$(normalize_vrf_name $vrf)
	if [ $? -ne 0 ]; then
		echo "Invalid VRF"
		return 1
	fi

	#
	# create systemd service file for VRF
	#
	f=${SYSTEMD_DIR}/${name}.service
	if [ ! -e $f ]; then
		cp $MGMT_VRF_SERVICE $f
		sed -ie "s/start-systemd-vrf mgmt/start-systemd-vrf $vrf/" $f
		sed -ie "s/Description=Management VRF/Description=VRF $vrf/" $f
	fi

	systemctl enable ${name}.service
	systemctl start  ${name}.service
}

#
# stop and disable systemd user instance for a VRF
#
function systemd_disable_vrf
{
	local vrf=$1
	local f

	# do not check existence of vrf device; it can be deleted before
	# process shutdown

	name=$(normalize_vrf_name $vrf)
	if [ $? -ne 0 ]; then
		echo "Invalid VRF"
		return 1
	fi

	# disable VRF service

	systemctl stop ${name}.service
	rc=$?
	systemctl disable ${name}.service

	#
	# remove systemd service file except for mgmt vrf
	#
	f=${SYSTEMD_DIR}/${name}.service
	if [ "$f" != "$MGMT_VRF_SERVICE" ]; then
		rm -f $f
	fi

	return $rc
}

#
# add an entry from the onboot config file
#
function add_service_onboot
{
	local vrf=$1
	local service=$2
	local cfg=${CFGDIR}/${vrf}.conf

	mkdir -p ${CFGDIR}
	touch ${cfg}

	grep -q ${service} ${cfg}
	[ $? -eq 0 ] && return

	echo ${service} >> ${cfg}
}

#
# remove an entry from the onboot config file
#
function rm_service_onboot
{
	local vrf=$1
	local service=$2
	local cfg=${CFGDIR}/${vrf}.conf

	if [ ! -e ${cfg} ]; then
		return
	fi

	while read s
	do
		[ "$s" != "$service" ] && echo $s
	done < ${cfg} > ${cfg}.new

	mv ${cfg}.new ${cfg}
}

#
# See if a service is running in the default VRF context. If so
# attempts to start service in other VRF will fail.
#
function check_default_vrf
{
	local service=$1

	systemctl -n 0 status ${service}.service 2>/dev/null | egrep -q 'Active.*running'
	if [ $? -eq 0 ]; then
		echo "Service is currently running in default VRF."
		return 1
	fi

	systemctl -n 0 status ${service}.service 2>/dev/null | egrep -q 'Loaded.*enabled'
	if [ $? -eq 0 ]; then
		echo "Service is currently enabled in default VRF."
		return 1
	fi

	return 0
}

#
# start a service within a VRF context
#
function systemd_start
{
	local vrf=$1
	local onboot="no"
	local service

	valid_vrf $vrf || return 1

	vrf_exists $vrf
	if [ $? -ne 0 ]; then
		echo "VRF does not exist"
		return 1
	fi

	vrf_cgroup_exists $vrf || return 1

	shift
	if [ "$1" = "onboot" ]; then
		onboot=yes
		shift
	fi

	service=$1
	if [ -z "$service" ]; then
		echo "Service not given"
		return 1
	fi

	#
	# is this service running in default context?
	#
	check_default_vrf $service || return 1

	# make sure systemd in VRF is enabled
	systemd_enable_vrf $vrf
	[ $? -ne 0 ] && return 1

	#
	# create symlink for service to user directory
	#
	if [ ! -e ${SYSTEMD_USER}/${service}.service ]; then
		if [ ! -f ${SYSTEMD_DIR}/${service}.service ]; then
			echo "systemd service file not found."
			return 1
		fi
		ln -s ${SYSTEMD_DIR}/${service}.service ${SYSTEMD_USER}
	fi

	if [ "$onboot" = "yes" ]; then
		add_service_onboot ${vrf} ${service}
	fi

	XDG_RUNTIME_DIR=/run/systemd-${vrf}
	export XDG_RUNTIME_DIR

	systemctl --user start ${service}
}

function systemd_stop
{
	local vrf=$1
	local onboot="no"
	local service

	valid_vrf $vrf || return 1

	shift
	if [ "$1" = "onboot" ]; then
		onboot=yes
		shift
	fi

	service=$1
	if [ -z "$service" ]; then
		echo "Service not given"
		return 1
	fi

	XDG_RUNTIME_DIR=/run/systemd-${vrf}
	export XDG_RUNTIME_DIR

	if [ "$onboot" = "yes" ]; then
		rm_service_onboot ${vrf} ${service}
	fi

	systemctl --user stop $service
}

function systemd_status
{
	local vrf=$1
	local service=$2

	if [ -z "$vrf" ]; then
		vrf=$(task_identify)
	fi

	valid_vrf $vrf || return 1

	XDG_RUNTIME_DIR=/run/systemd-${vrf}
	export XDG_RUNTIME_DIR

	# empty ${service} gives status for all services
	systemctl --user status -l ${service}
}

function service_cmd
{
	local cmd=$1
	shift

	l3mdev_cgroup_exists
	[ $? -ne 0 ] && return 1

	case "$cmd" in
		start)  systemd_start $*;;
		stop)   systemd_stop $*;;
		status) systemd_status $*;;

		help) service_usage;;
		*) service_usage; return 1;;
	esac
}

################################################################################
# Management VRF

function mgmt_usage
{
	cat <<EOF

Management VRF domain:
    $PROG mgmt status
EOF
}

# Determine if management VRF is enabled. Check looks solely for
# the expected management VRF device name. If a customer / user
# decides to name it something else this check will fail.
# Can add check for eth0, eth1, ... enslavement (is it enslaved
# to a VRF device) but even that has limits.

function mgmt_status
{
	local rc
	local modstr

	vrf_exists $MGMT_VRF
	rc=$?

	# make sure mgmt device has at least 1 device enslaved
	# otherwise it means mgmt is defined but not used
	if [ $rc -eq 0 ]; then
		n=$(ip -br link show master $MGMT_VRF | wc -l)
		[ $n -eq 0 ] && rc=1
	fi

	[ $rc -ne 0 ] && modstr="NOT "
	echo "Management VRF is ${modstr}enabled."

	return $rc
}

function mgmt_cmd
{
	local cmd=$1
	shift

	case "$cmd" in
		status) mgmt_status $*;;

		# used by profile.d hook
		# $PROG mgmt set <pid>
		set) task_set $MGMT_VRF $*;;

		# return table id for MGMT_VRF. Used by dhclient hook
		# $PROG mgmt table
		table) vrf_table $MGMT_VRF;;

		# return name of management VRF device. Used by ping and
		# traceroute wrapper.
		dev) echo $MGMT_VRF; return 0;;

		help) mgmt_usage;;
		*) mgmt_usage; return 1;;
	esac
}

################################################################################
# usage

function usage
{
	cat <<EOF
$PROG <OPTS>

VRF domains:
    $PROG list
EOF
	link_usage
	route_usage
	task_usage
	service_usage
	mgmt_usage
}

################################################################################
# main

CMD=$1
shift
case "$CMD" in
	ls|list|sh|show) vrf_list $*;;

	# bash profile scripts for checking if a vrf exists
	# $PROG exists <vrf-name>
	exists) vrf_exists $*;;

	# task commands
	t|ta|task) task_cmd $*;;

	# allowed shortcut: $PROG exec <vrf> <cmd>
	exec) task_cmd  exec $*;;

	s|service)  service_cmd $*;;

	# vrf identify   (show VRF for task)
	id|identify)   task_identify $*;;

	li|link)  link_cmd $*;;
	ro|route) route_cmd $*;;

	m|mgmt) mgmt_cmd $*;;

	####################################################
	# these options are for testing and tooling; they
	# are not intended for use by customers
	add)        vrf_add $*;;
	del|delete) vrf_delete $*;;

	c|cgroup)     vrf_cgroup $*;;
	# end unsupported options
	####################################################

	help) usage; exit 0;;
	*) usage; exit 1;;
esac
