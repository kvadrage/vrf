#!/bin/bash
#
# VRF admin script
#
# This script is mostly a wrapper around ip and cgroups commands used to
# create and configure VRFs. The intent is to provide a better and cleaner
# user experience for managing VRFs on Linux. Perhaps one day this becomes
# a subcommand of ip (ip vrf ...)

PROG=${0##*/}

# Expected name of managment VRF device
# TO-DO: should this be in a config file?
MGMT_VRF=mgmt

SYSTEMD_DIR=/lib/systemd/system
SYSTEMD_USER=/etc/systemd/user
MGMT_VRF_SERVICE=${SYSTEMD_DIR}/mgmt-vrf.service
CFGDIR=/var/lib/cumulus-vrf

################################################################################
# utilities

function dev_exists
{
	ip link show dev ${1} >/dev/null 2>&1
}


# return device index for given device name

function dev_index
{
	local dev=$1
	local idx

	dev_exists ${dev} || return 1

	idx=$(ip -o link show dev ${1} | awk '{print $1}')
	idx=${idx/:}
	echo $idx

	[ -z "$idx" ] && return 1

	return 0
}

# Look up master device for a link

function dev_get_master
{
	local dev=$1

	ip -o link show dev $dev | awk '{
	for (i = 0; i < NF; ++i)
		if ($i == "master") {
			j=i+1
			print $j
			i=NF
		}
	}'
}

function get_comm
{
	awk '$1 == "Name:" {print $2}' /proc/$1/status
}

function normalize_vrf_name
{
	local vrf=$1

	[ -z "$vrf" ] && return 1

	case "$vrf" in
		*vrf*) name=$vrf;;
		*) name=${vrf}-vrf;;
	esac

	echo $name
	return 0
}

################################################################################
# cgroup functions

function l3mdev_cgroup_exists
{
	if [ -e /sys/fs/cgroup/l3mdev ];
	then
		return 0
	fi

	echo
	echo "Cgroup for managing VRF context does not exist."
	echo "Has l3mdev cgroup patch been applied to kernel?"
	echo "If so has it been enabled?"
	echo

	return 1
}

function vrf_cgroup_exists
{
	local vrf=$1

	[ -e /sys/fs/cgroup/l3mdev/${vrf} ] && return 0

	echo "cgroup does not exist for VRF."

	return 1
}

# return l3mdev cgroup task is associated with
function vrf_get_cgroup
{
	local p=$1
	local c

	c=$(grep l3mdev /proc/$p/cgroup | awk -F':' '{print $NF}')
	# strip leading '/'; makes default VRF ""
	echo ${c/\/}
}

function vrf_cgroup
{
	local vrf=$1

	l3mdev_cgroup_exists
	[ $? -ne 0 ] && return 0

	# configure cgroup
	which cgcreate >/dev/null 2>&1
	if [ $? -ne 0 ]; then
		echo "cgcreate not found. cgroups tools installed?"
		return 1
	fi
	cgcreate -g l3mdev:${vrf}

	which cgset >/dev/null 2>&1
	if [ $? -ne 0 ]; then
		echo "cgset not found. cgroups tools installed?"
		return 1
	fi
	cgset -r l3mdev.master-device=${vrf} ${vrf}
}

################################################################################
# vrf device functions

function vrf_exists
{
	local vrf=${1}

	[ "$vrf" = "default" ] && return 0

	dev_exists $vrf
}

# get table id for vrf device
function vrf_get_table
{
	ip -d link show dev ${1} 2>/dev/null | \
	awk '{
		for (i=1; i<NF; ++i) {
			if ($i == "table") {
				j=i+1
				id=$j
			}
		}
	} END { print id }'
}

function vrf_table
{
	local vrf=$1
	
	vrf_exists $vrf
	if [ $? -ne 0 ]; then
		echo "VRF does not exist"
		return 1
	fi

	vrf_get_table $vrf
}

# return list of VRFs that have been created
function vrf_get_list
{
	local c

	if [ "$1" != "-a" ]; then
		c=$(vrf_get_cgroup $$)

		# if task is associated with vrf only return that vrf
		if [ -n "$c" ]; then
			echo $c
			return 0
		fi
	fi

	ip -br link show type vrf | awk '{print $1}'
}

# create a VRF device, add FIB rules, set VRF link up, create id to table
# for iproute2
function do_vrf_create
{
	local vrf=$1
	local tbid=$2

	# make sure there are no vestiges from previous vrfs with name
	do_vrf_delete ${vrf} ${tbid}

	# create device
	ip link add ${vrf} type vrf table ${tbid}

	# echo "${tbid}  ${vrf}" > /etc/iproute2/rt_tables.d/${vrf}.conf

	# setup fib rules which direct lookups to the proper table
	ip ru add pref 200 oif ${vrf} table ${tbid}
	ip ru add pref 200 iif ${vrf} table ${tbid}
	ip -6 ru add pref 200 oif ${vrf} table $tbid
	ip -6 ru add pref 200 iif ${vrf} table $tbid

	# setup default route for vrf - use a very poor metric so other
	# default routes will take precedence. We need a default route
	# to keep the lookups from dropping from one table to the next
	ip route add table ${tbid} unreachable default metric 100
	ip -6 route add table ${tbid} unreachable default metric 100

	ip link set dev ${vrf} up

	vrf_cgroup $vrf
}

# Do VRF clean up even if vrf device does not exist
function do_vrf_delete
{
	local vrf=$1
	local tbid=$2

	# rm -f /etc/iproute2/rt_tables.d/${vrf}.conf

	exec 2>/dev/null

	# stop and disable and systemd services that might be running
	systemd_disable_vrf ${vrf}

	ip link delete dev ${vrf}

	if [ -n "$tbid" ]; then
		ip route flush table ${tbid}
		ip -6 route flush table ${tbid}
	fi

	ip ru delete oif ${vrf}
	ip ru delete iif ${vrf}
	ip -6 ru delete oif ${vrf}
	ip -6 ru delete iif ${vrf}

	cgdelete -g l3mdev:${vrf}
}

function vrf_list
{
	local tbid
	local vrf

	if [ -n "$1" ]; then
		usage
		return 1
	fi

	printf "\n"
	printf "%-16s %-5s\n" "VRF" "Table"
	printf "%-16s %-5s\n" "----------------" "-----"

	vrf=$(vrf_get_list -a)
	for v in $vrf
	do
		tbid=$(vrf_get_table $v)
		printf "%-16s %5s\n" $v $tbid
	done

	echo

	return 0
}

# Unsupported option; for testing and tooling only
function vrf_add
{
	local vrf=${1}

	if [ "$2" != "table" -o -z "$3" -o -n "$4" ];
	then
		usage
		return 1
	fi

	if [ "${vrf}" = "default" ]; then
		echo "'default' is a reserved VRF name"
		return 1
	fi

	vrf_exists ${vrf}
	if [ $? -eq 0 ]; then
		echo "VRF already exists"
		return 1
	fi

	do_vrf_create ${vrf} $3
}

# Unsupported option; for testing and tooling only
function vrf_delete
{
	local vrf=${1}
	local tbid

	if [ -z "$1" -o -n "$2" ];
	then
		usage
		return 1
	fi

	if [ "${vrf}" = "default" ]; then
		echo "Can not delete the default VRF"
		return 1
	fi

	tbid=$(vrf_get_table $vrf)
	do_vrf_delete ${vrf} ${tbid}
}

################################################################################
# link management

function link_usage
{
	cat <<EOF

Links associated with VRF domains:
    $PROG link list [<vrf-name>]
EOF
    # Unsupported options for customers; tooling and automated testing only
    # $PROG link add <vrf-name> dev <dev-name>
    # $PROG link remove dev <dev-name>
}

function link_list_vrf
{
	local vrf=${1}

	dev_exists $vrf
	if [ $? -ne 0 ]; then
		echo "VRF does not exist"
		return 1
	fi

	echo
	echo "VRF $vrf"
	echo "--------------------"

	ip -br link show master ${vrf}
}

function link_list
{
	local vrf=$1

	if [ -n "$2" ];
	then
		link_usage
		return 1
	fi

	if [ -z "$vrf" ]; then
		vrf=$(vrf_get_list)
	fi

	for v in $vrf
	do
		link_list_vrf ${v}
	done

	echo
}

function link_add
{
	local vrf=${1}
	local dev=$3

	if [ "$2" != "dev" -o -z "$3" -o -n "$4" ];
	then
		link_usage
		return 1
	fi

	dev_exists $vrf
	if [ $? -ne 0 ]; then
		echo "VRF does not exist"
		return 1
	fi

	dev_exists $dev
	if [ $? -ne 0 ]; then
		echo "dev does not exist"
		return 1
	fi

	ip link set dev $dev master ${vrf}
}

function link_remove
{
	local dev=$2

	if [ "$1" != "dev" -o -z "$2" -o -n "$3" ];
	then
		link_usage
		return 1
	fi

	dev_exists $dev
	if [ $? -ne 0 ]; then
		echo "dev does not exist"
		return 1
	fi

	ip link set dev $dev nomaster
}

function link_cmd
{
	local cmd=$1
	shift

	case "$cmd" in
		l|li|ls|list) link_list   $*;;

		####################################################
		# these options are for testing and tooling; they
		# are not intended for use by customers
		a|add)        link_add    $*;;
		r|rem|remove) link_remove $*;;
		####################################################

		help)         link_usage;;
		*)            link_usage; return 1;;
	esac
}

################################################################################
# route management

function route_usage
{
cat <<EOF

Routes for a VRF domain:
    $PROG route list [<vrf-name>]
EOF
    # Unsupported options for customers; tooling and automated testing only
    # $PROG route {add|delete} <vrf-name> <route spec>
    # $PROG route get <vrf-name> <host>
}

function route_show_vrf
{
	local vrf=${1}

	dev_exists $vrf
	if [ $? -ne 0 ]; then
		echo "VRF does not exist"
		return 1
	fi

	local tbid=$(vrf_get_table $vrf)

	echo
	echo "VRF $vrf" 
	echo "--------------------"

	ip route show table $tbid
	echo
	ip -6 route show table $tbid
}

function route_show
{
	local vrf=${1}

	if [ -n "$2" ];
	then
		route_usage
		return 1
	fi

	if [ -z "$vrf" ];
	then
		vrf=$(vrf_get_list)
	fi

	for v in ${vrf}
	do
		route_show_vrf ${v}
	done

	echo
}

function route_add
{
	local vrf=${1}
	shift

	dev_exists $vrf
	if [ $? -ne 0 ]; then
		echo "VRF does not exist"
		return 1
	fi
	local tbid=$(vrf_get_table $vrf)

	ip route add table $tbid $*
}

function route_delete
{
	local vrf=${1}
	shift

	dev_exists $vrf
	if [ $? -ne 0 ]; then
		echo "VRF does not exist"
		return 1
	fi
	local tbid=$(vrf_get_table $vrf)

	ip route del table $tbid $*
}

function route_get
{
	local vrf=${1}
	shift

	dev_exists $vrf
	if [ $? -ne 0 ]; then
		echo "VRF does not exist"
		return 1
	fi

	ip route get oif $vrf $*
}

function route_cmd
{
	local cmd=$1
	shift

	case "$cmd" in
		s|sh|show|li|ls|list)  route_show $*;;
		get)          route_get $*;;

		####################################################
		# these options are for testing and tooling; they
		# are not intended for use by customers
		a|add)        route_add $*;;
		d|del|delete) route_delete $*;;
		####################################################

		help)         route_usage;;
		*)            route_usage; return 1;;
	esac
}


################################################################################
# task management

function task_usage
{
	cat <<EOF

Tasks and VRF domain asociation:
    $PROG task exec <vrf-name> <command>
    $PROG task list [<vrf-name>]
    $PROG task identify <pid>
EOF
}

function task_list_vrf
{
	local vrf=$1

	printf "\n"
	printf "VRF %s\n" $vrf
	echo "-----------------------"

	local f="/sys/fs/cgroup/l3mdev/${vrf}/cgroup.procs"
	if [ ! -e $f ]; then
		echo "No cgroup for vrf"
	else
		while read p
		do
			c=$(get_comm $p)
			printf "%-16s  %5s\n" $c $p
		done < $f
	fi
}

# show VRF for specific task
function task_identify
{
	local do_prompt=0

	if [ "$1" = "prompt" ]; then
		do_prompt=1
		shift
	fi

	# allow syntax to be ... pid <pid>
	[ "$1" = "pid" ] && shift
	pid=$*

	# default to parent PID (not this commands PID)
	[ -z "$pid" ] && pid=$PPID

	c=$(vrf_get_cgroup $pid)
	if [ -n "$c" ]; then
		if [ $do_prompt = "1" ]; then
			c=$(normalize_vrf_name $c)
			echo ":$c"
		else
			echo "$c"
		fi
	elif [ $do_prompt != "1" ]; then
		echo "default"
	fi
}

function task_list
{
	local vrf

	# show all tasks in 1 or more VRFs
	vrf="$*"
	if [ -z "$vrf" ]; then
		vrf=$(vrf_get_list)
	fi

	for v in ${vrf}
	do
		task_list_vrf ${v}
	done

	echo
}

# This should only be used by experienced users and known contexts.
# Changing the context of a running task only affects future ipv4 and
# ipv6 sockets. This option is used by various OS scripts to set
# the context of a parent process before exec'ing another process
# - a proper example of this should be used.

function task_set
{
	local vrf=$1
	local pid=$2

	if [ -n "$3" ]; then
		task_usage
		return 1
	fi

	vrf_exists $vrf
	if [ $? -ne 0 ]; then
		echo "VRF does not exist"
		return 1
	fi
	[ -z "$pid" ] && pid=$PPID

	kill -0 $pid >/dev/null 2>&1
	if [ $? -ne 0 ]; then
		echo "Process does not exist"
		return 1
	fi

	if [ "$vrf" = "default" ]; then
		echo $pid >> /sys/fs/cgroup/l3mdev/cgroup.procs
	else
		vrf_cgroup_exists $vrf || return 1
		echo $pid >> /sys/fs/cgroup/l3mdev/${vrf}/cgroup.procs
	fi
}

function task_exec
{
	local vrf=$1
	shift

	vrf_exists $vrf
	if [ $? -ne 0 ]; then
		echo "VRF does not exist"
		return 1
	fi

	which cgexec >/dev/null 2>&1
	if [ $? -ne 0 ]; then
		echo "cgexec not found. cgroups tools installed?"
		return 1
	fi

	if [ "$vrf" = "default" ]; then
		cgexec -g l3mdev:/ $*
	else
		cgexec -g l3mdev:${vrf} $*
	fi
}

function task_cmd
{
	local cmd=$1
	shift

	l3mdev_cgroup_exists
	[ $? -ne 0 ] && return 1

	case "$cmd" in
		sh|show|li|list|ls) task_list $*;;
		id|identify) task_identify $*;;

		# used for systemd; needs to be hidden as there are
		# caveats to change the vrf association of a running
		# task
		set)         task_set $*;;

		ex|exec)     task_exec $*;;

		help) task_usage;;
		*) task_usage; return 1;;
	esac
}


################################################################################
# systemd integration

function service_usage
{
	cat <<EOF

Tasks running under systemd in a VRF domain:
    $PROG service start  <vrf> {onboot} <service>
    $PROG service stop   <vrf> {onboot} <service>
    $PROG service status <vrf> {<service>}
EOF
}


# Sanity check on VRF name
# - can not add device exists check here because disable/stop
#   commands need to run even if VRF device does not exist

function valid_vrf
{
	local vrf=$1

	if [ -z "$vrf" ]; then
		echo "VRF not given"
		return 1
	fi

	if [ "$vrf" = "default" ]; then
		echo "This command is only used for non-default VRFs"
		return 1
	fi

	if [ "$vrf" != "$MGMT_VRF" ]; then
		echo "This command is currently limited to management VRF."
		return 1
	fi

	return 0
}

#
# Enable and start systemd user instance for a VRF
#
function systemd_enable_vrf
{
	local vrf=$1
	local f

	vrf_exists $vrf
	if [ $? -ne 0 ]; then
		echo "VRF does not exist"
		return 1
	fi

	# convert VRF name to systemd service name
	# - want to include "vrf" in the service name

	name=$(normalize_vrf_name $vrf)
	if [ $? -ne 0 ]; then
		echo "Invalid VRF"
		return 1
	fi

	#
	# create systemd service file for VRF
	#
	f=${SYSTEMD_DIR}/${name}.service
	if [ ! -e $f ]; then
		cp $MGMT_VRF_SERVICE $f
		sed -ie "s/start-systemd-vrf mgmt/start-systemd-vrf $vrf/" $f
		sed -ie "s/Description=Management VRF/Description=VRF $vrf/" $f
	fi

	systemctl enable ${name}.service
	systemctl start  ${name}.service
}

#
# stop and disable systemd user instance for a VRF
#
function systemd_disable_vrf
{
	local vrf=$1
	local f

	# do not check existence of vrf device; it can be deleted before
	# process shutdown

	name=$(normalize_vrf_name $vrf)
	if [ $? -ne 0 ]; then
		echo "Invalid VRF"
		return 1
	fi

	# disable VRF service

	systemctl stop ${name}.service
	rc=$?
	systemctl disable ${name}.service

	#
	# remove systemd service file except for mgmt vrf
	#
	f=${SYSTEMD_DIR}/${name}.service
	if [ "$f" != "$MGMT_VRF_SERVICE" ]; then
		rm -f $f
	fi

	return $rc
}

#
# add an entry from the onboot config file
#
function add_service_onboot
{
	local vrf=$1
	local service=$2
	local cfg=${CFGDIR}/${vrf}.conf

	mkdir -p ${CFGDIR}
	touch ${cfg}

	grep -q ${service} ${cfg}
	[ $? -eq 0 ] && return

	echo ${service} >> ${cfg}
}

#
# remove an entry from the onboot config file
#
function rm_service_onboot
{
	local vrf=$1
	local service=$2
	local cfg=${CFGDIR}/${vrf}.conf

	if [ ! -e ${cfg} ]; then
		return
	fi

	while read s
	do
		[ "$s" != "$service" ] && echo $s
	done < ${cfg} > ${cfg}.new

	mv ${cfg}.new ${cfg}
}

#
# See if a service is running in the default VRF context. If so
# attempts to start service in other VRF will fail.
#
function check_default_vrf
{
	local service=$1

	systemctl -n 0 status ${service}.service 2>/dev/null | egrep -q 'Active.*running'
	if [ $? -eq 0 ]; then
		echo "Service is currently running in default VRF."
		return 1
	fi

	systemctl -n 0 status ${service}.service 2>/dev/null | egrep -q 'Loaded.*enabled'
	if [ $? -eq 0 ]; then
		echo "Service is currently enabled in default VRF."
		return 1
	fi

	return 0
}

#
# start a service within a VRF context
#
function service_start
{
	local vrf=$1
	local onboot="no"
	local service

	valid_vrf $vrf || return 1

	vrf_exists $vrf
	if [ $? -ne 0 ]; then
		echo "VRF does not exist"
		return 1
	fi

	vrf_cgroup_exists $vrf || return 1

	shift
	if [ "$1" = "onboot" ]; then
		onboot=yes
		shift
	fi

	service=$1
	if [ -z "$service" ]; then
		echo "Service not given"
		return 1
	fi

	#
	# is this service running in default context?
	#
	check_default_vrf $service || return 1

	# make sure systemd in VRF is enabled
	systemd_enable_vrf $vrf
	[ $? -ne 0 ] && return 1

	#
	# create symlink for service to user directory
	#
	if [ ! -e ${SYSTEMD_USER}/${service}.service ]; then
		if [ ! -f ${SYSTEMD_DIR}/${service}.service ]; then
			echo "systemd service file not found."
			return 1
		fi
		ln -s ${SYSTEMD_DIR}/${service}.service ${SYSTEMD_USER}
	fi

	if [ "$onboot" = "yes" ]; then
		add_service_onboot ${vrf} ${service}
	fi

	XDG_RUNTIME_DIR=/run/systemd-${vrf}
	export XDG_RUNTIME_DIR

	systemctl --user start ${service}
}

function service_stop
{
	local vrf=$1
	local onboot="no"
	local service

	valid_vrf $vrf || return 1

	shift
	if [ "$1" = "onboot" ]; then
		onboot=yes
		shift
	fi

	service=$1
	if [ -z "$service" ]; then
		echo "Service not given"
		return 1
	fi

	XDG_RUNTIME_DIR=/run/systemd-${vrf}
	export XDG_RUNTIME_DIR

	if [ "$onboot" = "yes" ]; then
		rm_service_onboot ${vrf} ${service}
	fi

	systemctl --user stop $service
}

function service_status
{
	local vrf=$1
	local service=$2

	if [ -z "$vrf" ]; then
		vrf=$(task_identify)
	fi

	valid_vrf $vrf || return 1

	XDG_RUNTIME_DIR=/run/systemd-${vrf}
	export XDG_RUNTIME_DIR

	# empty ${service} gives status for all services
	systemctl --user status -l ${service}
}

function service_cmd
{
	local cmd=$1
	shift

	l3mdev_cgroup_exists
	[ $? -ne 0 ] && return 1

	case "$cmd" in
		start)  service_start $*;;
		stop)   service_stop $*;;
		status) service_status $*;;

		# hidden command for ifupdown2 when it deletes a VRF
		# $PROG service disable <vrf>
		disable) systemd_disable_vrf $*;;

		help) service_usage;;
		*) service_usage; return 1;;
	esac
}

################################################################################
# Management VRF

function mgmt_usage
{
	cat <<EOF

Management VRF domain:
    $PROG mgmt status
EOF
}

# Determine if management VRF is enabled. Check looks solely for
# the expected management VRF device name. If a customer / user
# decides to name it something else this check will fail.
# Can add check for eth0, eth1, ... enslavement (is it enslaved
# to a VRF device) but even that has limits.

function mgmt_status
{
	local rc
	local modstr

	vrf_exists $MGMT_VRF
	rc=$?

	# make sure mgmt device has at least 1 device enslaved
	# otherwise it means mgmt is defined but not used
	if [ $rc -eq 0 ]; then
		n=$(ip -br link show master $MGMT_VRF | wc -l)
		[ $n -eq 0 ] && rc=1
	fi

	[ $rc -ne 0 ] && modstr="NOT "
	echo "Management VRF is ${modstr}enabled."

	return $rc
}

function mgmt_cmd
{
	local cmd=$1
	shift

	case "$cmd" in
		status) mgmt_status $*;;

		# used by profile.d hook
		# $PROG mgmt set <pid>
		set) task_set $MGMT_VRF $*;;

		# return table id for MGMT_VRF. Used by dhclient hook
		# $PROG mgmt table
		table) vrf_table $MGMT_VRF;;

		# return name of management VRF device. Used by ping and
		# traceroute wrapper.
		dev) echo $MGMT_VRF; return 0;;

		help) mgmt_usage;;
		*) mgmt_usage; return 1;;
	esac
}

################################################################################
# verify config for existing vrfs

# Run a few checks against management vrf expectations

function verify_mgmt_vrf
{
	local mgmt_exists=0
	local rc=0
	local mdev

	echo

	vrf_exists $MGMT_VRF
	if [ $? -ne 0 ]; then
		echo "Management VRF does not exist"
	else
		mgmt_exists=1
		echo "Management VRF exists"

		mdev=$(ip -br li sh master $MGMT_VRF | awk '{print $1}')
		if [ -z "$mdev" ]; then
			echo "    ERROR: Management VRF exists with no enslaved devices"
			rc=1
		else
			echo "    Management VRF interface: " $mdev
		fi
	fi

	# eth0 should exist and be checked with warning level
	# eth1 may exist and it is just informational

	local level="WARNING: "
	for d in eth0 eth1
	do
		dev_exists $d || continue

		m=$(dev_get_master $d)
		if [ -n "$m" ]; then
			if [ "$m" = "$MGMT_VRF" ]; then
				echo "    $d is enslaved to Management VRF"
			else
				echo "    ${level}$d is enslaved to $m"
			fi
		else
			if [ $mgmt_exists -eq 1 ]; then
				echo "    ${level}$d is not enslaved to management VRF"
			else
				echo "    $d is not enslaved"
			fi
		fi
		level="INFO: "
	done

	return $rc
}

function verify_vrf_cgroup
{
	local vrf=$1

	vrf_cgroup_exists $vrf >/dev/null 2>&1
	if [ $? -ne 0 ]; then
		echo "    ERROR: cgroup does not exist"
		return 1
	fi

	idx=$(dev_index $vrf)
	if [ $? -ne 0 ]; then
		echo "    ERROR: Failed to get device index; cgroup may be misconfigured"
		return 1
	fi

	# l3mdev.master-device file has line:
	#     net[4026531957]: device index 62 ==> red
	# important part is the index N ==> dev-name

	grep -q "index $idx ==> $vrf" /sys/fs/cgroup/l3mdev/${vrf}/l3mdev.master-device
	if [ $? -ne 0 ]; then
		echo "    ERROR: cgroup is misconfigured"
		return 1
	fi

	echo "    cgroup looks ok"

	return 0
}

function verify_local_table
{
	local rc=0

	echo
	echo "Checking rules for local table:"

	ip ru ls | egrep -q "^0:.*from all lookup local"
	if [ $? -eq 0 ]; then
		echo "    ERROR: IPv4 rule for local table should be after VRFs"
		rc=1
	fi

	ip -6 ru ls | egrep -q "^0:.*from all lookup local"
	if [ $? -eq 0 ]; then
		echo "    ERROR: IPv6 rule for local table should be after VRFs"
		rc=1
	fi

	[ $rc -eq 0 ] && echo "    rules for local tables look ok"

	return $rc
}

function ip_ru_verify
{
	local vrf=$1
	local tbid=$2
	local ver=$3
	local desc="IPv4"
	local cmd="ip ru ls"
	local rc=0
	local d

	if [ "$ver" = "6" ]; then
		desc="IPv6"
		cmd="ip -6 ru ls"
	fi

	# make sure the FIB rules exist; routing requires it

	for d in iif oif
	do
		$cmd | grep -q "from all $d $vrf lookup $vrf"
		if [ $? -ne 0 ]; then
			$cmd | grep -q "from all $d $vrf lookup $tbid"
			if [ $? -ne 0 ]; then
				echo "    ERROR: $desc $d fib rule is missing (see $cmd)"
				rc=1
			fi
		fi

		# make sure there is only 1 FIB rule; duplicate rules affect
		# performance
		n=$($cmd | grep "from all $d $vrf lookup" | wc -l)
		if [ $n -gt 1 ]; then
			echo "    WARNING: More than 1 $desc $d fib rules are present (see $cmd)"
			rc=1
		fi
	done

	return $rc
}

function verify_vrf_fib_rules
{
	local vrf=$1
	local tbid=$2
	local rc=0

	ip_ru_verify $vrf $tbid "4"
	[ $? -ne 0 ] && rc=1
	ip_ru_verify $vrf $tbid "6"
	[ $? -ne 0 ] && rc=1

	[ $rc -eq 0 ] && echo "    FIB rules look ok"

	return $rc
}

function verify_cmd
{
	local vrf
	local tbid
	local rc=0
	local n=0

	n=$(ip -br link show type vrf | wc -l)
	if [ $n -eq 0 ]; then
		echo "No VRFs have been configured"
		return 0
	fi

	verify_mgmt_vrf
	[ $? -ne 0 ] && rc=1

	vrf_get_list -a | 
	while read vrf
	do
		# managemnet vrf handled in verify_mgmt_vrf
		[ "$vrf" = "$MGMT_VRF" ] && continue

		echo

		tbid=$(vrf_get_table $vrf)
		if [ -z "$tbid" ]; then
			echo "ERROR: VRF $vrf: failed to get table id; VRF is misconfigured"
			rc=1
			continue
		fi

		echo "VRF $vrf table $tbid"

		verify_vrf_fib_rules $vrf $tbid
		[ $? -ne 0 ] && rc=1

		verify_vrf_cgroup $vrf
		[ $? -ne 0 ] && rc=1
	done

	verify_local_table
	[ $? -ne 0 ] && rc=1

	ip ru ls | grep -q '\[detached\]'
	if [ $? -eq 0 ]; then
		echo
		echo "ERROR: Detached IPv4 FIB rules need to be removed. See ip ru ls"
	fi

	ip -6 ru ls | grep -q '\[detached\]'
	if [ $? -eq 0 ]; then
		echo
		echo "ERROR: Detached IPv6 FIB rules need to be removed. See ip ru ls"
	fi

	echo

	return $rc
}

################################################################################
# usage

function usage
{
	cat <<EOF
$PROG <OPTS>

VRF domains:
    $PROG list
EOF
	link_usage
	route_usage
	task_usage
	service_usage
	mgmt_usage
}

################################################################################
# main

CMD=$1
shift
case "$CMD" in
	ls|list|sh|show) vrf_list $*;;

	# bash profile scripts for checking if a vrf exists
	# $PROG exists <vrf-name>
	exists) vrf_exists $*;;

	# task commands
	t|ta|task) task_cmd $*;;

	# allowed shortcut: $PROG exec <vrf> <cmd>
	exec) task_cmd  exec $*;;

	s|service)  service_cmd $*;;

	# vrf identify   (show VRF for task)
	id|identify)   task_identify $*;;

	li|link)  link_cmd $*;;
	ro|route) route_cmd $*;;

	m|mgmt) mgmt_cmd $*;;

	####################################################
	# these options are for testing and tooling; they
	# are not intended for use by customers
	add)        vrf_add $*;;
	del|delete) vrf_delete $*;;

	c|cgroup)   vrf_cgroup $*;;
	verify)     verify_cmd;;
	# end unsupported options
	####################################################

	help) usage; exit 0;;
	*) usage; exit 1;;
esac
